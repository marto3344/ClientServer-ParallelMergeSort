
---
# Client - Server Parallel MergeSort
## Мартин Стоянов
**Фак. Номер:** 5MI800390  **Курс:** 3  **Група:** 1
---

## Архитектура

Приложението следва класическия **Client-Server** модел, оптимизиран за висока производителност под Linux.

### Server Side 
Сървърът е проектиран да бъде **non-blocking** по отношение на приемането на връзки, но използва **worker threads** за тежките изчисления.

1.  **I/O Multiplexing (Epoll):**
    *   Главната нишка използва `epoll_wait`, за да следи слушащия сокет.
    *   Това позволява на сървъра да поддържа множество отворени връзки с минимален разход на ресурси, избягвайки проблемите на класическия `select`.
    *   При нова връзка (`accept`), клиентският дескриптор се подава директно към Thread Pool-а.

2.  **Thread Pool:**
    *   Набор от предварително създадени нишки, които чакат задачи в опашка.
    *   Предотвратява overhead-а от постоянното създаване и унищожаване на нишки за всяка нова заявка.
    *   Всяка нишка в басейна чете данните от клиента, извършва сортирането и връща резултата.

3.  **Parallel Merge Sort:**
    *   Алгоритъмът използва стратегията "Разделяй и владей".
    *   **Дълбочина на рекурсията:** Изчислява се като $depth = \log_2(N_{threads})$.
    *   **Task Distribution:** За всяко ниво на дълбочината се създава нова нишка (`std::thread`) за лявата половина на масива, докато текущата нишка обработва дясната.
    *   **Threshold Optimization:** Когато подмасивът стане достатъчно малък (< 10,000 елемента) или дълбочината се изчерпи, алгоритъмът превключва към **последователен Merge Sort**, за да избегне излишното създаване на нишки и съответно 
    context switching overhead.

### Client Side 
Клиентското приложение е конзолно и предлага гъвкав интерфейс за управление на данните и измерване на производителността:

1.  **Гъвкав Вход :**
    *   **Бинарен файл:** Клиентът може да чете данни от предварително генерирани бинарни файлове. Този метод е силно оптимизиран за четене на огромни масиви за секунди. В първите 8 байта трябва да бъдат записани броят на елементите на масива.
    *   **Стандартен вход: ** Поддържа се и ръчно въвеждане на размера и елементите на масива директно от клавиатурата. Тази опция е удобна за бързи проверки, дебъгване и малки тестови примери.

2.  **Гъвкав Изход:**
    *   След успешно получаване на сортирания масив, потребителят избира как да запази резултата:
        *   **Експорт в текстов файл (.txt):** Записва сортираните числа във файл, всяко на нов ред, което е удобно за последваща проверка.
        *   **Стандартен изход (Console):** Извежда резултата директно в терминала (препоръчително само за малки масиви).

3.  **Измерване на времето на заявката:**
    *   Използва `std::chrono::high_resolution_clock` за засичане на пълното време на заявката (Round-trip time).
    *   Използва флага `MSG_WAITALL` при комуникация, за да гарантира целостта на данните при големи трансфери.

### 3. Тестови генератор
В главната директория `generate_random_vec.cpp` след като се компилира, при вход от командия ред име на файл (двоичен) и брой елементи, генерира вектор от цели числа с дадения размер и го записва в дадения файл. Това улеснява тестването с големи масиви.

```bash
g++ generate_random_vec.cpp -o generator.out
./generator.out vec1 1000000
```

## Комуникационен Протокол

Обменът на данни е изцяло бинарен (Binary Stream) върху TCP/IP. Няма текстови хедъри, което минимизира латентността.

### Структура на заявката:

| Поредност | Тип | Размер (Bytes) | Описание |
| :--- | :--- | :--- | :--- |
| 1 | `int` | 4 | Желан брой нишки за сортиране. |
| 2 | `size_t` | 8 (на 64-bit) | Размер на масива (брой елементи). |
| 3 | `int[]` | $N \times 4$ | Самият масив от данни. |

## Резултати

Тестовете са проведени с масив от **10 милиона** цели числа (`int`), прочетен от бинарен файл.
CPU: Intel i3-8145U (4) @ 2.304GHz 
| Нишки (Threads) | Време (Total Request Time) | Скорост (Speedup) |
| :---: | :---: | :---: |
| **1** | ~4.71 s | 1.0x (Baseline) |
| **4** | ~2.20 s | **~2.14x Faster** |

*Времето включва: Четене на файл -> Изпращане по мрежата -> Сортиране -> Връщане на резултата -> Запис.*
